<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="style.css">
  <title>My Website</title>
</head>

<body>
  <!-- Header -->
  <section id="header">
    <div class="header container">
      <div class="nav-bar">
        <div class="brand">
          <a href="#hero">
            <h1><span>C</span>itypedia</h1>
          </a>
        </div>
        <div class="nav-list">
          <div class="hamburger">
            <div class="bar"></div>
          </div>
          <ul>
            <li><a href="#hero" data-after="Home">Home</a></li>
            <li><a href="#comparison" data-after="Comparison">Comparison</a></li>
            <li><a href="#number" data-after="Number">Number</a></li>
            <li><a href="#efficiency" data-after="Efficiency">Efficiency</a></li>
            <li><a href="#quiz" data-after="Quiz">Quiz</a></li>
            <li><a href="#contact" data-after="Contact">Contact</a></li>
          </ul>
        </div>
      </div>
    </div>
  </section>
  <!-- End Header -->


  <!-- Hero Section  -->
  <section id="hero">
    <div class="hero container">
      <div>
        <h1>Hello we are Group 21, <span></span></h1>
        <h1>This website is all about <span></span></h1>
        <h1>Sorting Method<span></span></h1>
        <a href="#number" type="button" class="cta">Numbers</a>
      </div>
    </div>
  </section>
  <!-- End Hero Section  -->

  <!-- Background Section -->
  <section id="background">
    <div class="background container">
      <div class="col-right">
        <h1 class="section-title"><span>B</span>ackground</h1>
        <h2>Let's have a brief understanding of what sorting methods are.</h2>
        <p>In the discipline of programming and computer science, sorting methods hold an irreplaceable role contributing as a fundamental algorithm block for arranging data in an inferable and productive way. 
          The exploration of different sorting methods includes a diverse range of techniques, ranging from simple and intuitive approaches like Bubble Sort to sophisticated and efficient methods such as Merge Sort and Quick Sort. 
          To reorder an array or list of elements, a sorting algorithm is implemented based on a comparison operator applied to the elements. Sorting means reordering of all the elements either in ascending or in descending order. </p>
      </div>
    </div>
  </section>
  <!-- End background Section -->

  <!-- application Section -->
  <section id="application">
    <div class="application container">
      <div class="application-top">
        <h1 class="section-title"><span>A</span>pplication</h1>
        <p>Sorting methods are essential tools in a wide range of applications across various industries and disciplines. These algorithms are instrumental in organizing and arranging data in a structured manner. The following are some general ways in which sorting methods are commonly used in applications</p>
      </div>
      <div class="application-bottom">
        <div class="application-item">
          <div class="icon"><img src="./img/unnamed.png" /></div>
          <h2>Database Management</h2>
          <p>Sorting algorithms are commonly used in database management systems to sort and index large volumes of data. This ensures quick retrieval of information and faster processing.</p>
        </div>
        <div class="application-item">
          <div class="icon"><img src="./img/unnamed.png" /></div>
          <h2>E-commerce and Retail</h2>
          <p>cIn e-commerce platforms, sorting methods are employed to arrange products based on various parameters such as price, popularity, ratings, etc. This enhances user experience by presenting relevant and personalized product information</p>
        </div>
        <div class="application-item">
          <div class="icon"><img src="./img/unnamed.png" /></div>
          <h2>Search Engines</h2>
          <p>Search engines utilize sorting algorithms to rank search results based on relevance, user preferences, and other criteria. Sorting ensures that the most relevant content is personalized to users</p>
        </div>
        <div class="application-item">
          <div class="icon"><img src="./img/unnamed.png" /></div>
          <h2>Finance and Banking</h2>
          <p>Sorting methods play a vital role in financial institutions for organizing transaction records, customer data, and financial documents. They are used for tasks such as report generation and risk assessment</p>
        </div>
        <div class="application-item">
          <div class="icon"><img src="./img/unnamed.png" /></div>
          <h2>Logistics and Supply Chain Management</h2>
          <p>Sorting algorithms are applied in optimizing supply chain operations by arranging inventory, tracking shipments, and determining efficient routes for transportation. This streamlines the logistics processes and minimizes transportation delays</p>
        </div>
        <div class="application-item">
          <div class="icon"><img src="./img/unnamed.png" /></div>
          <h2>Data Analysis and Research</h2>
          <p>Researchers and analysts use sorting methods to organize and process large datasets for statistical analysis and pattern identification</p>
        </div>
        <div class="application-item">
          <div class="icon"><img src="./img/unnamed.png" /></div>
          <h2>Telecommunications and Networking</h2>
          <p>Sorting algorithms are employed in network routing protocols to help in managing network traffic and ensuring smooth communication between devices</p>
        </div>

      </div>
    </div>
  </section>
  <!-- End application Section -->

  <!-- Features  Section -->
  <section id="background">
    <div class="background container">
      <div class="col-right">
        <h1 class="section-title"><span>M</span>ain <span>F</span>aeatures</h1>
        <h2>The features of different sorting methods.</h2>
        <p>(a) Internal sorting: Using main memory only during sorting are called internal sorting algorithms. Such an algorithm assumes a high speed random access to all memory. Some common algorithms that use this option are: Bubble Sort, Insertion Sort., and Quick Sort.</p>
        <p>(b) External sorting: Uses external memory, come into this category when they are sorted. They are slower than internal sorting algorithms. such as the merge sort algorithm. It sorts the appropriate blocks into each RAM, and then combines the sorted blocks.</p>
        <p>(c) Stable sorting: It keeps the relative order of elements with the same key as they are sorted. On the other hand, if two objects have the same key value, the stable sorting ensures that their original order is preserved in sorted output. </p>
        <p>(d) Unstable sorting: There are no overhead is required to preserve the order of the same objects, and this sorting method are faster. Unstable sorting is not guaranteed to preserve their relative order in the original list in the sorted output. This sorting algorithms are often used when ordering of similar features is not necessary or can be ignored.</p>
        <p>(e) In-place sorting & out-of place sorting: It operates directly on the input data structure without the need for additional space relative to the main input. In other words, it transforms the input rather than a separate copy of the data structure. The unlocated algorithm is sometimes referred to as out-of place sorting. </p>
      </div>
    </div>
  </section>
  <!-- Features  Section -->


  <!-- Comparison Section -->
  <section id="comparison">
    <div class="comparison container">
      <div class="comparison-top">
        <h1 class="section-title"><span>C</span>omparison</h1>
        <p>This section is about comparing different sorting method</p>
      </div>
      <div class="comparison-bottom">
        <div class="comparison-item">
          <div class="icon"><img src="./img/comparison.png" /></div>
          <h2>Internal vs External</h2>
          <p>Internal processing is used when input data can be prepared once in main memory while external processing is used when input data cannot be prepared at once in main memory.</p>
        </div>
        <div class="comparison-item">
          <div class="icon"><img src="./img/comparison.png" /></div>
          <h2>Stable vs Unstable</h2>
          <p>The stable sorting algorithm preserves the relative order of the same objects, while the unstable sorting algorithm does not. In other words, the invariant order maintains the position of two identical objects relative to each other. </p>
        </div>
        <div class="comparison-item">
          <div class="icon"><img src="./img/comparison.png" /></div>
          <h2>In-place vs Out-of place </h2>
          <p>In-Place means that your sorting algorithm uses no extra memory except the array for sorting, while out-of-place means that your sorting algorithm uses extra memory. </p>
        </div>
      </div>
    </div>
  </section>
  <!-- End comparison Section -->

  <!-- Number Section -->
  <section id="number">
    <div class="number container">
      <div class="number-header">
        <h1 class="section-title">Sorting <span>Numbers</span></h1>
      </div>
      <div class="all-number">
        <div class="project-item">
          <div class="project-info">
            <h1>Internal sorting</h1>
            <p>For this example, we can use the quick sort method to sort it as internal sorting takes a pivot element, then divides the data set into two sub-arrays, one sub-array larger than the element and the other sub-array smaller than the element The same process is repeated for the sub-arrays until if the structure of the data set as shown below happens. </p>
          </div>
          <div class="project-img">
            <img src="https://www.baeldung.com/wp-content/uploads/sites/4/2021/08/insertion-sort-v1-1.png" alt="img">
          </div>
        </div>
        <div class="project-item">
          <div class="project-info">
            <h1>External sorting</h1>
            <p>External algorithms require algorithms whose spatial complexity does not increase with the size of the data set. While the space complexity of the Merge Sort is O(n), we can make changes in O(1). From the example below, It shows a computer with 8GB RAM and high data flow sorting data size of 50 GB using Merge Sort Algorithm. </p>
          </div>
          <div class="project-img">
            <img src="https://www.baeldung.com/wp-content/uploads/sites/4/2021/08/external-sort-2.png" alt="img">
          </div>
        </div>
        <div class="project-item">
          <div class="project-info">
            <h1>Stable and Unstable sorting</h1>
          <p>We have an array of integers A:  [ 5, 8, 9, 8, 3 ]. We will use 8 in the case and represent the array using color-coded balls, where any two balls with the same integer will have a different color which would help us keep track of equal elements. Stable sorting maintains the order of two identical balls numbered 8s, while an unstable sorting may evolve into a system of two 8s.</p>
          </div>
          <div class="project-img">
            <img src="https://www.baeldung.com/wp-content/uploads/2019/08/Stable-vs-Unstable-1.png" alt="img">
          </div>
        </div>
        <div class="project-item">
          <div class="project-info">
            <h1>In-place sorting</h1>
            <p>First, we will assume that we want to invert an array of n numbers. If we think about the problem, we will see that we have an input array and a reversed array as output. In the end, we don’t really need the original design, just the adapted version. We would only need one more variable to store the values is currently working on: It is worth mentioning that no matter the size of the array, the extra space we need will always be O(1) in this case. </p>
          </div>
          <div class="project-img">
            <img src="https://www.baeldung.com/wp-content/uploads/2019/08/Screen-Shot-2019-08-07-at-3.40.33-PM.png" alt="img">
          </div>
        </div>
        <div class="project-item">
          <div class="project-info">
            <h1>Out-of-place sorting</h1>
          
            <p>For the out-of place sorting, we can do this more simply, and even more clearly. We can create a new array of the same size and basically copy the values in the corresponding order and then delete the original array: While this will do the job we want, it doesn't work well enough. O(n) has extra space because we have two arrays in use. In addition, creating and removing new systems is usually a slow process.</p>
          </div>
          <div class="project-img">
            <img src="https://www.baeldung.com/wp-content/uploads/2019/08/Screen-Shot-2019-08-07-at-3.40.22-PM.png" alt="img">
          </div>
        </div>
      </div>
    </div>
  </section>
  <!-- End Number Section -->

  <!-- Efficiency Section -->
  <section id="efficiency">
    <div class="efficiency container">
      <div class="col-right">
        <h1 class="section-title"><span>E</span>ffectiveness</h1> 
        <h3>Internal Sorting Algorithms</h3>
        <p>The effectiveness of internal sorting algorithms can be evaluated based on these following factors:</p>
        <ol>
          <li>Time Complexity: The efficiency of internal sorting algorithms is often measured by their time complexity. Algorithms with lower time complexity, such as O(n log n) for quicksort or merge sort, are considered more effective as they can handle large datasets efficiently.</li>
          <li>Space Complexity: Internal sorting algorithms are expected to use a minimal amount of extra space. Algorithms that do not require additional space allocation aside from the input array are preferred.</li>
          <li>Stability: Stability refers to maintaining the relative order of equal elements in the sorted output. Effective internal sorting algorithms should preserve the order of elements with the same value.</li>
          <li>Adaptability: Some internal sorting algorithms can adapt their behaviour based on the initial order of the input data. Adaptive algorithms can perform better when the data is partially sorted.</li>
          <li>Ease of Implementation: The ease of understanding and implementing an internal sorting algorithm is also a factor in its effectiveness. Algorithms that are clear and straightforward are often preferred in practice.</li>
        </ol>
        <br>
        <h3>External Sorting Algorithms</h3>
        <p>The effectiveness of external sorting algorithms is evaluated based on these following factors:</p>
        <ol>
          <li>I/O Efficiency: Since external sorting involves frequent read and write operations to disk, the efficiency of I/O operations is crucial. Effective external sorting algorithms minimize the number of disk accesses and optimize data transfer between internal memory and external storage.</li>
          <li>Time Complexity: The time complexity of external sorting algorithms is influenced by the number of disk accesses and the efficiency of merge operations. Algorithms with lower time complexity, such as O(n log n) for external merge sort, are considered more effective in handling large datasets.</li>
          <li>Space Complexity: While external sorting algorithms require additional space in external storage, effective algorithms aim to minimize the space overhead and make efficient use of available disk space.</li>
          <li>Scalability: The effectiveness of external sorting algorithms is often assessed based on their ability to scale to large datasets. Algorithms that can efficiently handle varying data sizes and adapt to different disk configurations are preferred.</li>
          <li>Fault Tolerance: Since disk operations are prone to errors and failures, effective external sorting algorithms should incorporate mechanisms for error handling, recovery, and fault tolerance to ensure data integrity.</li>
        </ol>
        <br>
        <h3>Stable Sorting Algorithms</h3>
        <p>The effectiveness of stable sorting algorithms is evaluated based on these following factors:</p>
        <ol>
          <li>Preservation of Order: The primary advantage of stable sorting algorithms is their ability to preserve the order of elements with equal keys. This characteristic is useful in scenarios where maintaining the original order of equal elements is important.</li>
          <li>Applications: Stable sorting is particularly useful in situations where the original order of equivalent elements carries significance, such as sorting a list of people based on their arrival time or sorting records based on multiple keys.</li>
          <li>Predictability: Stable sorting algorithms provide predictable outcomes, ensuring that the sorting results remain consistent even for identical keys.</li>
          <li>Merge Operations: Certain sorting algorithms, such as merge sort, can be implemented to be stable. The effectiveness of stable sorting can be evaluated based on the efficiency of merge operations while maintaining stability.</li>
        </ol>
        <br>
        <h3>Unstable sorting algorithms</h3>
        <p>The effectiveness of unstable sorting algorithms is assessed based on different criteria compared to stable sorting algorithms: </p>
        <ol>
          <li>Performance: Unstable sorting algorithms may often be more efficient in terms of performance compared to stable sorting algorithms. The lack of need to maintain the order of equal elements can sometimes lead to faster sorting processes.</li>
          <li>Space Complexity: Unstable sorting algorithms may require less memory or have better space complexity compared to stable sorting algorithms since they do not need additional steps to maintain the order of elements with the same key. </li>
          <li>Simplicity: Unstable sorting algorithms can be simpler to implement and understand since they do not need to consider the order preservation of equal elements. </li>
          <li>Adaptability: Unstable sorting algorithms may be more adaptable in certain scenarios where maintaining equal element order is not necessary or desired. They can be more flexible in handling different types of data. </li>
        </ol>
        <br>
        <h3>In-place sorting algorithms</h3>
        <p>The effectiveness of in-place sorting algorithms is evaluated based on several criteria: </p>
        <ol>
          <li>Space Complexity: In-place sorting algorithms are efficient in terms of space complexity as they do not need additional memory allocation to store a copy of the input data. They use a constant amount of extra space regardless of the input size, making them memory efficient. </li>
          <li>Time Complexity: The time complexity of in-place sorting algorithms varies depending on the algorithm used. Many in-place sorting algorithms have good time complexity, making them efficient for large datasets. </li>
          <li>Efficiency: In-place sorting algorithms are preferred for scenarios where memory usage is a concern or when there are memory constraints. They are efficient in terms of memory usage.  </li>
          <li>Stability: Some in-place sorting algorithms can be implemented to be stable, preserving the order of equal elements in the sorted output. The stability of the algorithm can add to its effectiveness in certain applications.  </li>
        </ol>
        <br>
        <h3>Out-of-place</h3>
        <p>The effectiveness of out-of-place sorting depends on several factors: </p>
        <ol>
          <li>Stability: Out-of-place sorting algorithms are generally stable, meaning they do not change the relative order of equal elements. </li>
          <li>Space Complexity: Out-of-place algorithms usually have higher space complexity compared to in-place algorithms. If memory usage is a concern, in-place sorting might be more efficient.</li>
          <li>Time Complexity: The time complexity of out-of-place sorting algorithms can differ from in-place algorithms. In some cases, out-of-place algorithms might perform better due to reduced data movement operations.</li>
          <li>Clarity and Readability: Out-of-place algorithms can be easier to understand and implement since they do not modify the original data structure.</li>
        </ol>
      </div>
    </div>
  </section>
  <!-- End efficiency Section -->

  <!-- Quiz Section -->
  <section id="quiz">
    <div class="quiz container">
      <div class="contact-top">
        <h1 class="section-title"><span>Q</span>uiz</h1>
          <p>Let's do a quiz. Test your understanding of Sorting Methods!</p>
      </div>
      <div class="quiz-item">
        <a href="https://cityutestwebsite.github.io/CS1102_G21/quiz.html" class="gtq">Take a quiz</a>
      </div>
    </div>
  </section>
  <!-- End Quiz Section -->

  <!-- Contact Section -->
  <section id="contact">
    <div class="contact container">
      <div class="contact-top">
        <h1 class="section-title">Contact <span>info</span></h1>
          <p>We are a group of students at City University of Hong Kong</p>
          <p>We produce this website to demonstrate our skills in coding in HTML and CSS. Explaining the knowledge about different sorting methods and sharing the experiences with others.</p>
      </div>
      <div class="contact-item">
          <div class="icon"><img src="https://img.icons8.com/bubbles/100/000000/new-post.png" /></div>
          <div class="contact-info">
            <h1>Email</h1>
            <h2>cityutestapp@gmail.com</h2>
            <h2></h2>
          </div>
          </div>
        <a href="#" class="cta">Back To Top</a>
      </div>
    </div>
  </section>
  <!-- End Contact Section -->

  <!-- Footer -->
  <section id="footer">
    <div class="footer container">
      <div class="brand">
        <h1><span>C</span>itypedia<span></h1>
      </div>
      <h2>Your Complete Storting Website</h2>
      <p></p>
    </div>
  </section>
  <!-- End Footer -->
  <script src="./app.js"></script>
</body>

</html>
